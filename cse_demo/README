The comparison shopping engine capability is a part of an comparison shopping engine (CSE). Comparison shopping engines collect data directly from merchants and retailers who want to list their data on the CSE website. The merchants can send a feed of their products that need to be listed on the website. The CSE in turn, may have technology that aggregates all the data, matches or correlates them with each other and presents it to its users. 

Here, we are not interested in the intricacies of how a CSE functions. Rather, we want to demonstrate, how easy it is for a merchant(s) to publish their data to a CSE engine. This use case will demonstrate how a merchant can publish their inventory using X.commerce platform. This merchant can be a small local store or a huge online marketplace like Google. As it is more interesting and useful to a developer in terms of illustrating multiple X.commerce concepts, we will demonstrate how a merchant can publish products from Google marketplace to the CSE capability. The CSE in turn stores this information.

While this use case itself will evolve to include more complex and rich scenarios of the Fabric's interaction with multiple capabilities, we begin with a demonstration of the simplest scenario. There will be two capabilities - CSE publisher and CSE. The CSE publisher publishes the Google Marketplace data to the fabric on a topic that the CSE is subscribed to receive. The CSE receives this message and stores the data in a mongo database. A complete working PHP sample is provided.

Publisher
Download the Avro PHP library from the X.commerce github repository. This contains the changes to the core Avro files for parsing the X.commerce contracts.  ï»¿_PUT_LINK_TO_GITREPO_HERE. Include that file.
include_once 'avro.php';
An Avro message is essentially a binary message that adheres to the encoding schema. If the message your are creating does not adhere to the schema, it won't be serialized. This ensures uniformity and also serves as a way to validate the messages that are being transmitted via the Fabric. 
Authentication and schema information and two of the important information that gets transmitted via the HTTP headers of the messages going to and coming from the Fabric. An outgoing message might have the following sample header scheme
Content-Type: avro/binary => This sets the content type to avro/binary
Authorization: Bearer QUkAAZORF/BpTsy9+pKy6iFIjPu1Wc+/XKD... => This is the authorization token. Care should be taken to ensure that this is accurate or else the message wont be delivered to the intended receiving capabilities.
X-XC-SCHEMA-VERSION: 1.0.0 => This represents the schema version that will be used to decode the message. Based on this version number and the topic, a schema URI is constructed. _SHOW_EXAMPLE_HERE_. For instance, if the topic is /cse/offer/create, the schema can be found from https://ocl..../cse/offer/create/v/1.0.0/
X-XC-SCHEMA-URL: http://myserver/custom_contract.avpr" => This header is used to define a custom contract location in sandbox environment. This is not used in production, but for this example we will use this header to point to the CSE contract as it is not stored on the OCL cloud yet.
This will translate to the following PHP code
$ch = curl_init();

	// The URL is the host:port for the XFabric, plus the topic
	curl_setopt($ch, CURLOPT_URL, "https://localhost:8080/cse/offers/create");
	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
	curl_setopt($ch, CURLOPT_HEADER, true);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($ch, CURLOPT_TIMEOUT, 10);
	curl_setopt($ch, CURLOPT_POST, 1);
	curl_setopt($ch, CURLOPT_HTTPHEADER, array("Content-Type: avro/binary", "Authorization: Bearer QUkAAZORF/BpTsy9+pKy6iFIjPu1Wc+/XKDZQCjve56KgXxpXvdIzTHykSlSbC4bdwsQ1A==","X-XC-SCHEMA-VERSION: 1.0.0", "X-XC-SCHEMA-URL: http://localhost/fabric_post/contracts/cse.avpr"));


	// Send the message
	curl_setopt($ch, CURLOPT_POSTFIELDS, $write_io->string());
Sending messages - The publisher will send messages in Avro binary format. The message payload is serialized without the schema. The schema is passed by as reference as explained previously. THe publisher will use the schema version and topic to construct an URI or use the schema url header to serialize the messages. The topic that the CSE consumer is listening is /cse/offer/create. We will post our Avro message to that topic.
$schema = AvroSchema::parse($content);
$datum_writer= new AvroIODatumWriter($schema);
$write_io = new AvroStringIO();
$encoder = new AvroIOBinaryEncoder($write_io);
If everything goes well, you will see a 200 message from the Fabric.

HTTP/1.1 200 OK
X-XC-MESSAGE-GUID: 15f15795-fd73-4801-a173-36a37f704991
Content-Length: 0
Server: Jetty(6.1.x) 
Google product data adapter
In this example, we used Google's product search API to publish to the CSE. It is possible to query a JSON product data by directing a GET request on the relevant Google end point. For example, we can fetch a list of iPhones from https://www.googleapis.com/shopping/search/v1/public/products/?key=KEY&q=iphone&country=US. You can sign up for a Google API key HERE (ADD_LINK_HERE).  Using a function, similar to the following, you can get a list of products in the form of a PHP array.

function getGoogleProducts($apikey, $query)
{
	$url = "https://www.googleapis.com/shopping/search/v1/public/products/?key=".$apikey."&q=".$query."&country=US";
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $url);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
	$data = json_decode(curl_exec($ch), true);
	return $data["items"];
}
However, this data returned from the Google API call should be translated to the CSE message format as defined by the schema. A sample function is shown that lets an user convert the JSON data decoded from Google API call into a CSE message format.

/function takes the data returned by google shopping search api and
//converts it into a CSE message
function convertGoogleDataToCSEMessage($items)
{
	//create a test message for cse
	$products = array();
	foreach ($items as $item) {
		$product = $item["product"];
		//add a condition for if inventories exist -> determines sale price
		//get the first item in the inventory
		$inventory_item = array_shift($product["inventories"]);
		$price = $inventory_item["price"];
		$currency = $inventory_item["currency"];
		$availability = ucfirst($inventory_item["availability"]);
		//from google, some product availability is returned as unknown
		//that will make the schema fail.
		if ($availability == "Unknown") { $availability = "InStock"; }

		$ind_product = array("sku" => $product["googleId"],
						"tile" => $product["title"],
						"description" => $product["description"],
						"manufacturer" => $product["author"]["name"],
						"MPN" => "NA",
						"GTIN" => "NA",
						"brand" => $product["brand"],
						"category" => "NA",
						"images" => array(),//$product["images"],
						"link" => $product["link"],
						"condition"=>ucfirst($product["condition"]),
						"salePrice" => array("amount" => $price, "code" =>$currency),
						"originalPrice" => array("amount" => $price, "code" =>$currency),
						"availability" => $availability,
						"taxRate" =>array("country" => "US", "region" => "TX", "rate"=> 8.5, "taxShipping" => false),
						"shipping" => array("country" => "US", "region" => "TX", "service" => "UPS", "price" => array("amount" => 3.99, "code" =>"USD")),
						"shippingWeight" => 0.0,
						"attributes" => array(),
						"variations" => array(),
						"offerId" => "NA",
						"cpc" => array("amount" => 0.0, "code" =>"USD"));
		array_push($products,$ind_product);

	}
	$message = array("products" => $products, "productFeedType" => "Full");

	//$message = array("products" => array(array("sku" => "123","tile" => "iphone", "description" => "test iphone","manufacturer" => "apple", "MPN" => "123", "GTIN" => "123", "brand" => "apple", "category" => "electronics", "images" => array(), "link" => "", "condition"=>"New", "salePrice" => array("amount" => 500.0, "code" =>"dollars"), "originalPrice" => array("amount" => 500.0, "code" =>"dollars"), "availability" => "InStock", "taxRate" =>array("country" => "US", "region" => "TX", "rate"=> 8.5, "taxShipping" => false), "shipping" => array("country" => "US", "region" => "TX", "service" => "UPS", "price" => array("amount" => 10.0, "code" =>"dollars")), "shippingWeight" => 10.0, "attributes" => array(), "variations" => array(), "offerId" => " ", "cpc" => array("amount" => 500.0, "code" =>"dollars"))), "productFeedType" => "Full");
	return $message;
}
Consumer
The first thing to do in the consumer is to deserialize the message using the Schema from the header. The right way to do this in the production environment would be to use X-XC-SCHEMA-URI header and parse the schema from there. But, in experimental environments, if we want to test our custom schema, we can do something like the following -

if (isset($headers['X-XC-SCHEMA-URL'])){
			//get the schema from this place and parse it.
			$content = file_get_contents($headers['X-XC-SCHEMA-URL']);
		}
		else {
			//get it from X-XC-SCHEMA-URI, the default location
			$content = file_get_contents($headers['X-XC-SCHEMA-URI']);
		}
This will ensure that we are looking for the custom schema first and using it if it exists.

This message can be easily decoded now that we have the schema.

	$datum_reader = new AvroIODatumReader($schema);
		$read_io = new AvroStringIO($post_data);
		$decoder = new AvroIOBinaryDecoder($read_io);
		$message = $datum_reader->read($decoder);
This message can be stored in a database for retrieval and post processing. A way to do that using Mongo would be -

//write to mongodb
		$conn = new Mongo('localhost');
		// access database
	    $db = $conn->cse_data;
	    // access collection
	    $collection = $db->google;
	    // insert a new document
	   $item = $message["products"];
	   $collection->insert($item);
This will store the product data in the local database.
